// Пояснения:
// 1. Смета формируется на основе XML-текста и использует XSD-схему,
// схема доработана так как ГрандСмета долго не обновляет схему после обновления ПО.
// 2. Схема гарантирует что в определенных случаях при наличие одного элемента будут и другие,
// например при наличии Tzm.Price всегда указано Tzm.Quantity,
// при наличии свойства PriceCurr всегда существует Quantity, value и некоторые другие.
// 3. Многие свойства являются списковыми но всегда хранят только одно значение
// поэтому обращение по прямому индексу 0 к этим объектам обусловлено спецификой ГрандСметы.
// 4. В коде можно встретить "магические строки". Это вызвано тем, что одна и та же строка
// в зависимости от контекста имеет разный смысл для сметы,
// их значение определено там где назначение понятно из контекста, для
// остальных случаев используются глобальные константы

#Область ОписаниеПеременных

Перем КэшНаименований; // Кэш используемый для хранения соответствия строки наименования и ее хеша
Перем МассивХешейНаименований; // Массив хешей используется для поиска соответствий в справочнике по набору хешей
Перем ИНДЕКС_ПЕРВОГО_ЭЛЕМЕНТА; // XSD схема для определенных элементов, которые могут находиться в документе
// в единственном числе, тем не менее устанавливает для них тип списка.
Перем ТИП_ВИДОВ_РАБОТ, ТИП_ВИДА_РАБОТ; // Идентификаторы устанавливающие типы видов работ из перечней видов работ.
Перем СТАРЫЙ_СПОСОБ_РАСЧЕТА, НОВЫЙ_СПОСОБ_РАСЧЕТА; // Синонимы для свойств элемента позволяющие определить
// по какой методике расчитывается зарплата рабочих
Перем СТОИМОСТЬ_МАТЕРИАЛОВ, СТОИМОСТЬ_ЭКСПЛУАТАЦИИ_МАШИН, // Синонимы для свойств элементов
СВОЙСТВО_КОЛИЧЕСТВО, СВОЙСТВО_ТЕКУЩАЯ_ЦЕНА; // таких как количество материала, его цена
#КонецОбласти

#Область ФормированиеОбъектаСметы

// Получает на вход сырой XML-документ из ГрандСметы
// воспроизводит расчеты, устанавливает связи между элементами
// и возвращает его древовидное представление
// Параметры:
//	Текст - Строка - XML документ получаемый из ГрандСметы
// Возвращаемое значение:
//	Структура - структура содержит древовидное представление документа сметы и ее заголовки
Функция СформироватьОбъектСметы(Текст) Экспорт
	
	Если НЕ ЗначениеЗаполнено(Текст) Тогда
		ВызватьИсключение "Текст сметы не может быть пустым";
	КонецЕсли;
	Попытка
		Схема = ПолучитьОбъектСхемыXMLДокумента();
		ОбъектXML = ПолучитьОбъектЧтенияXMLСметы(Текст, Схема);
		ДокументСметы = ПолучитьДокументСметы(ОбъектXML, Схема);
		ЗаголовкиСметы = ПолучитьЗаголовкиСметы(ОбъектXML);
		
		ОбъектСметы = СоздатьОбъектСметыИРассчитатьПозиции(ДокументСметы);
		ЗаполнитьСоответствияПоХешуНаименования(ОбъектСметы);
		
		Смета = Новый Структура;
		Смета.Вставить("ЗаголовкиДокумента", ЗаголовкиСметы);
		Смета.Вставить("СтруктураДокумента", ОбъектСметы.Смета);
		
		Возврат Смета;
	Исключение
		ТекстОшибки = СтрШаблон("Ошибка в функции %1: %2",
		"СформироватьОбъектСметы", ОписаниеОшибки());
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
КонецФункции

// Формирует схему для документа сметы
// BSLLS:LatinAndCyrillicSymbolInWord-off
Функция ПолучитьОбъектСхемыXMLДокумента()
	Попытка
		ТекстСхемы = ПолучитьМакет("Макет").ПолучитьТекст();
		ЧтениеСхемы = Новый ЧтениеXML;
		ЧтениеСхемы.УстановитьСтроку(ТекстСхемы);
		Построитель = Новый ПостроительDOM;
		Документ = Построитель.Прочитать(ЧтениеСхемы);
		Построитель = Новый ПостроительСхемXML;
		Схема = Построитель.СоздатьСхемуXML(Документ.ЭлементДокумента);
		Набор = Новый НаборСхемXML;
		Набор.Добавить(Схема);
		Возврат Набор;
	Исключение
		ТекстОшибки = СтрШаблон("Ошибка в функции %1: %2",
		"ПолучитьОбъектСхемыXMLДокумента", ОписаниеОшибки());
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
КонецФункции

Функция ПолучитьОбъектЧтенияXMLСметы(Текст, Схема)
	Попытка
		Чтение = Новый ЧтениеXML;
		Чтение.УстановитьСтроку(Текст, , Схема);
		Возврат Чтение;
	Исключение
		ТекстОшибки = СтрШаблон("Ошибка в функции %1: %2",
		"ПолучитьОбъектЧтенияXMLСметы", ОписаниеОшибки());
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
КонецФункции
// BSLLS:LatinAndCyrillicSymbolInWord-on

Функция ПолучитьДокументСметы(ОбъектXML, Схема)
	Попытка
		Фабрика = Новый ФабрикаXDTO(Схема);
		ТипДокумента = Фабрика.Пакеты.Получить(1)
		.КорневыеСвойства.Получить("Document").Тип;
		Чтение = Новый ЧтениеXML;
		Чтение.УстановитьСтроку(ОбъектXML, , Схема);
		Возврат Фабрика.ПрочитатьXML(Чтение, ТипДокумента);
	Исключение
		ТекстОшибки = СтрШаблон("Ошибка в функции %1: %2",
		"ПолучитьДокументСметы", ОписаниеОшибки());
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
КонецФункции

// Получает заголовки сметы для последующего формирования дерева формы
Функция ПолучитьЗаголовкиСметы(ОбъектXML)
	Попытка
		Построитель = Новый ПостроительDOM;
		Документ = Построитель.Прочитать(ОбъектXML);
		
		ГлавыДокумента = "Chapters";
		НомерГлавыДокумента = ИНДЕКС_ПЕРВОГО_ЭЛЕМЕНТА;
		
		Разделы = Документ
		.ПолучитьЭлементыПоИмени(ГлавыДокумента)[НомерГлавыДокумента].ДочерниеУзлы;
		
		ЗаголовкиПозиций = Новый Соответствие;
		
		Для Каждого Раздел Из Разделы Цикл
			МассивЗаголовковРазделов = Новый Массив;
			
			Для Каждого Позиция Из Раздел.ДочерниеУзлы Цикл
				ПолучитьЗаголовкиПозиции(Позиция, МассивЗаголовковРазделов, ЗаголовкиПозиций);
			КонецЦикла;
		КонецЦикла;
		
		Возврат ЗаголовкиПозиций;
		
	Исключение
		ТекстОшибки = СтрШаблон("Ошибка в функции %1: %2",
		"ПолучитьЗаголовкиСметы", ОписаниеОшибки());
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
	Возврат Неопределено;
КонецФункции
Процедура ПолучитьЗаголовкиПозиции(Позиция, МассивЗаголовковРазделов, ЗаголовкиПозиций)
	
	Попытка
		НомерАтрибута = ИНДЕКС_ПЕРВОГО_ЭЛЕМЕНТА;
		
		Заголовок = "Header";
		СвойствоПозиция = "Position";
		ВнутреннийИдентификаторСметы = "SysID";
		
		Если Позиция.ИмяУзла = Заголовок И Позиция.Атрибуты.Количество() > 0 Тогда
			МассивЗаголовковРазделов.Добавить(Позиция.Атрибуты[НомерАтрибута].Значение);
		КонецЕсли;
		
		УзелПозиции = Позиция.СледующийСоседний;
		
		Если Позиция.ИмяУзла = Заголовок И УзелПозиции.ИмяУзла = СвойствоПозиция И Позиция.Атрибуты.Количество() > 0 Тогда
			Узел = УзелПозиции.ПолучитьИменованныйЭлемент(ВнутреннийИдентификаторСметы).Значение;
			ЗаголовкиПозиций.Вставить(Узел, МассивЗаголовковРазделов);
			МассивЗаголовковРазделов = Новый Массив;
		КонецЕсли;
	Исключение
		ТекстОшибки = СтрШаблон("Ошибка в функции %1: %2",
		"ПолучитьЗаголовкиПозиции", ОписаниеОшибки());
		ВызватьИсключение ТекстОшибки;
		
	КонецПопытки;
КонецПроцедуры

// Основная точка обработки XDTO
// Обходит главы и разделы сметы для извлечения и расчета позиций
// формирует структуру отражающую смету - с заголовками, разделами и позциями
// которые в дальнейшем используются для построения дерева на форме документа
// Параметры:
//	ДокументСметы - ОбъектXDTO - десериализованное представление сметы
// Возвращаемое значение:
//	Параметры - Структура - структура с заголовками сметы и расчитанными элементами
Функция СоздатьОбъектСметыИРассчитатьПозиции(ДокументСметы)
	ПоказателиРасходов = ПолучитьПоказателиРасходовПоИдентификаторуРабот(ДокументСметы);
	Параметры = Новый Структура;
	Параметры.Вставить("ПоказателиРасходов", ПоказателиРасходов);
	Параметры.Вставить("Смета", Новый Соответствие);
	
	ГлавыДокумента = ДокументСметы.Chapters;
	СвойствоГлава = "Chapter";
	НазваниеРаздела = "Caption";
	СвойствоПозиция = "Position";
	Для Каждого Глава Из ГлавыДокумента Цикл
		НомерРаздела = 0;
		
		Для Каждого Раздел Из Глава[СвойствоГлава] Цикл
			НомерРаздела = НомерРаздела + 1;
			
			НазваниеРаздела = Раздел[НазваниеРаздела];
			НазваниеРаздела = "Раздел " + НомерРаздела  + ". "  + НазваниеРаздела;
			Параметры.Смета.Вставить(НазваниеРаздела, Новый Массив);
			ПозицииРаздела = Раздел[СвойствоПозиция];
			Если ПозицииРаздела = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			РассчитатьПозицииРаздела(ПозицииРаздела, НазваниеРаздела, Параметры);
		КонецЦикла;
	КонецЦикла;
	
	Возврат Параметры;
КонецФункции
Функция ПолучитьПоказателиРасходовПоИдентификаторуРабот(Смета)
	Расходы = Новый Соответствие;
	КаталогиВидовРабот = "VidRab_Catalog";
	СписокВидовРабот = "Vids_Rab";
	СписокГруппыВидовРабот = "VidRab_Group";
	ОбъектРаботы = "Vid_Rab";
	НакладныеРасходы = "Nacl";
	ПлановыеРасходы = "Plan";
	
	Для Каждого КаталогВидовРабот Из Смета[КаталогиВидовРабот] Цикл
		Для Каждого ВидыРабот Из КаталогВидовРабот[СписокВидовРабот] Цикл
			Если ВидыРабот.Type = ТИП_ВИДОВ_РАБОТ Тогда
				ГруппыВидовРабот = ВидыРабот[СписокГруппыВидовРабот];
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	Для Каждого ГруппаВидовРабот Из ГруппыВидовРабот Цикл
		Для Каждого Работа Из ГруппаВидовРабот[ОбъектРаботы] Цикл
			
			ПоказателиРасходов = Новый Структура;
			ПоказателиРасходов.Вставить("НакладныеРасходы",
			?(Работа[НакладныеРасходы] <> Неопределено, Работа[НакладныеРасходы], 0));
			ПоказателиРасходов.Вставить("ПлановыеРасходы",
			? (Работа[ПлановыеРасходы] <> Неопределено, Работа[ПлановыеРасходы], 0));
			Расходы.Вставить(Работа.ID, ПоказателиРасходов);
			
		КонецЦикла;
	КонецЦикла;
	Возврат Расходы;
	
КонецФункции
#КонецОбласти

#Область РасчетПоТипуПозиции

// Получает позиции раздела из документа,
// рассчитывает их показатели и вставляет в структуру в сметы, в соответствующий раздел
Процедура РассчитатьПозицииРаздела(ПозицииРаздела, НазваниеРаздела, Параметры)
	Для Каждого Позиция Из ПозицииРаздела Цикл
		ТипЗатрат = ОпределитьТипЗатрат(Позиция);
		Коэффициенты = РассчитатьИПолучитьСписокКоэффициентов(Позиция);
		ОбъектПозиции = СоздатьОбъектПозицииСметы(Позиция, ТипЗатрат, Коэффициенты);
		
		Хеш = ВычислитьХешПозиции(ОбъектПозиции.Наименование, КэшНаименований);
		
		ОбъектПозиции.Хеш = Хеш;
		
		МассивХешейНаименований.Добавить(Хеш);
		
		Если ТипЗатрат = Перечисления.ТипыЗатрат.Работы Тогда
			Параметры.Смета.Получить(НазваниеРаздела).Добавить(ОбъектПозиции);
		КонецЕсли;
		
		РассчитатьПозициюПоТипуЗатрат(ОбъектПозиции, Позиция, Параметры, ТипЗатрат);
		
	КонецЦикла;
КонецПроцедуры
Процедура РассчитатьПозициюПоТипуЗатрат(ОбъектПозиции, СтрокаПозиции, Параметры, ТипЗатрат)
	Если ТипЗатрат = Перечисления.ТипыЗатрат.Работы Тогда
		ЗаполнитьКакВидРабот(ОбъектПозиции, СтрокаПозиции, Параметры);
	ИначеЕсли ТипЗатрат = Перечисления.ТипыЗатрат.Техника Тогда
		ЗаполнитьКакТехнику(ОбъектПозиции, СтрокаПозиции, Параметры);
	ИначеЕсли ТипЗатрат = Перечисления.ТипыЗатрат.Материалы Тогда
		ЗаполнитьКакМатериал(ОбъектПозиции, СтрокаПозиции, Параметры);
	Иначе
		ВызватьИсключение "В процедуру РассчитатьПозициюПоТипуЗатрат передан некорректный тип затрат";
	КонецЕсли;
КонецПроцедуры

Процедура ЗаполнитьКакВидРабот(ОбъектПозиции, СтрокаПозиции, Параметры)
	ПолучитьЗатратыПозиции(СтрокаПозиции, ОбъектПозиции);
	ПолучитьТехникуВидаРабот(СтрокаПозиции, ОбъектПозиции);
	Процент = 100;
	ПоказателиРасходов = Параметры.ПоказателиРасходов;
	
	Если СтрокаПозиции[ТИП_ВИДА_РАБОТ] <> Неопределено Тогда
		Расходы = ПоказателиРасходов.Получить(СтрокаПозиции[ТИП_ВИДА_РАБОТ]);
		Зарплата 	 = ОбъектПозиции.ОсновнаяЗарплата + ОбъектПозиции.ЗарплатаМехаников;
		ОбъектПозиции.НакладныеРасходы = Зарплата * (Расходы.НакладныеРасходы / Процент);
		ОбъектПозиции.ПлановыеРасходы = Зарплата * (Расходы.ПлановыеРасходы / Процент);
		СуммаВсего = ОбъектПозиции.Сумма
		+ Число(ОбъектПозиции.НакладныеРасходы)
		+ Число(ОбъектПозиции.ПлановыеРасходы);
		ОбъектПозиции.Вставить("СуммаВсего", СуммаВсего);
	КонецЕсли;
КонецПроцедуры

Процедура ЗаполнитьКакМатериал(ОбъектПозиции, СтрокаПозиции, Параметры)
	ТекущаяЦена = СтрокаПозиции[СВОЙСТВО_ТЕКУЩАЯ_ЦЕНА];
	Если ТекущаяЦена = Неопределено Тогда
		Возврат;
	КонецЕсли;
	ОбъектЦены = ИНДЕКС_ПЕРВОГО_ЭЛЕМЕНТА;
	ТекущаяЦенаМатериалов = ТекущаяЦена[ОбъектЦены][СТОИМОСТЬ_МАТЕРИАЛОВ];
	
	ОбъектПозиции.Цена 	= ТекущаяЦенаМатериалов;
	ОбъектПозиции.Сумма	= ТекущаяЦенаМатериалов * ОбъектПозиции.Количество;
	ОбъектПозиции.СтоимостьМатериалов = ОбъектПозиции.Сумма;
	ОбъектПозиции.Вставить("СуммаВсего", ОбъектПозиции.Сумма);
	ОбъектПозиции.Вставить("ДавальческийМатериал", ЭтоДавальческийМатериал(СтрокаПозиции, ОбъектПозиции.Код));
	
КонецПроцедуры
Процедура ЗаполнитьКакТехнику(ОбъектПозиции, СтрокаПозиции, Параметры)
	ТекущаяЦена = СтрокаПозиции[СВОЙСТВО_ТЕКУЩАЯ_ЦЕНА];
	Если ТекущаяЦена = Неопределено Тогда
		Возврат;
	КонецЕсли;
	ОбъектЦены = ИНДЕКС_ПЕРВОГО_ЭЛЕМЕНТА;
	ЦенаЭксплуатацииМашин = ТекущаяЦена[ОбъектЦены][СТОИМОСТЬ_ЭКСПЛУАТАЦИИ_МАШИН];
	
	ОбъектПозиции.Цена 	= ЦенаЭксплуатацииМашин;
	ОбъектПозиции.Сумма = ОбъектПозиции.Цена * ОбъектПозиции.Количество;
	ОбъектПозиции.ЭксплуатацияМашин = ОбъектПозиции.Сумма;
	ОбъектПозиции.Вставить("СуммаВсего", ОбъектПозиции.Сумма);
	ОбъектПозиции.Вставить("ДавальческийМатериал", ЭтоДавальческийМатериал(СтрокаПозиции, ОбъектПозиции.Код));
	
КонецПроцедуры
#КонецОбласти

#Область ОпределениеИВалидацияПозиции
// Набор правил для определения типа позиции по совокупности косвенных признаков
// Пытается определить тип по содержанию кода, наличию отдельных свойство
// специфичных для конкретного типа
// проверяет является ли позиция удаленной
Функция ОпределитьТипЗатрат(ПозицияСметы)
	
	КодПозиции = НРег(ПозицияСметы.Code);
	
	Если ЭтоВидРабот(ПозицияСметы, КодПозиции) Тогда
		Возврат Перечисления.ТипыЗатрат.Работы;
	ИначеЕсли ЭтоТехника(ПозицияСметы, КодПозиции) Тогда
		Возврат Перечисления.ТипыЗатрат.Техника;
	ИначеЕсли ЭтоМатериалы(ПозицияСметы, КодПозиции) Тогда
		Возврат Перечисления.ТипыЗатрат.Материалы;
	Иначе
		ВызватьИсключение "Ошибка: не удалось определить тип затрат";
	КонецЕсли;
КонецФункции
Функция ЭтоВидРабот(ПозицияСметы, КодПозиции)
	// BSLLS:Typo-off
	СписокРабот = ПозицияСметы.WorksList;
	КодРаботыГЭСН = "гэсн";
	КодРаботыКомплекс = "комплекс работ";
	// BSLLS:Typo-on
	
	Если СписокРабот = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат СписокРабот.Количество() > 0
	ИЛИ СтрНайти(КодПозиции, КодРаботыГЭСН) > 0  ИЛИ СтрНайти(КодПозиции, КодРаботыКомплекс) > 0;
КонецФункции
Функция ЭтоТехника(ПозицияСметы, КодПозиции)
	ТекущиеЦены = ПозицияСметы[СВОЙСТВО_ТЕКУЩАЯ_ЦЕНА];
	Если ТекущиеЦены.Количество() = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ОбъектЦены = ИНДЕКС_ПЕРВОГО_ЭЛЕМЕНТА;
	
	Возврат ТекущиеЦены.Количество() > 0 И ТекущиеЦены[ОбъектЦены][СТОИМОСТЬ_ЭКСПЛУАТАЦИИ_МАШИН] <> Неопределено;
КонецФункции
Функция ЭтоМатериалы(ПозицияСметы, КодПозиции)
	// BSLLS:Typo-off
	КодыМатериалов = "(?:фссцм|фсбцм|материал|прайс|гэснм)";
	КодМашинИМеханизмов = "фсбцмм";
	ТекущиеЦены = ПозицияСметы[СВОЙСТВО_ТЕКУЩАЯ_ЦЕНА];
	// BSLLS:Typo-on
	
	Если СтрНайти(КодПозиции, КодМашинИМеханизмов) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ТекущиеЦены <> Неопределено Тогда
		Для Каждого Цена Из ТекущиеЦены Цикл
			Если Цена[СТОИМОСТЬ_МАТЕРИАЛОВ] <> Неопределено Тогда
				Возврат Истина;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат СтрПодобнаПоРегулярномуВыражению(КодПозиции, КодыМатериалов);
КонецФункции

Функция ЭтаПозицияУдалена(ПозицияСметы)
	АтрибутыПозиции = ПозицияСметы.Attribs;
	Удален = "deleted";
	Если АтрибутыПозиции = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Для Каждого Аттрибут Из АтрибутыПозиции Цикл
		Если НРег(Аттрибут) = Удален Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
КонецФункции

Функция ЭтоДавальческийМатериал(ПозицияСметы, КодПозиции)
	Опции = ПозицияСметы.Options;
	МатериалЗаказчика = "материал заказчика";
	СвойствоМатериалЗаказчика = "RetOwnMat";
	
	Если Опции = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат СтрНайти(КодПозиции, МатериалЗаказчика) > 0 ИЛИ Опции.Найти(СвойствоМатериалЗаказчика) <> Неопределено;
КонецФункции
#КонецОбласти

#Область РасчетыЗатрат
// По совокупности свойств рассчитывает различные показатели каждой строки сметы
// В зависимости от типа позиции (вид работ, материалы) могут применяться различные
// варианты расчета
Процедура ПолучитьЗатратыПозиции(ПозицияСметы, СтруктураПозиции)
	Материалы = "Mat";
	Зарплата = "Tzr";
	Механизмы = "Mch";
	
	Количество = СтруктураПозиции.Количество;
	
	РесурсыПозиции = ПозицияСметы.Resources;
	ТекущиеЦеныПозиции = ПозицияСметы[СВОЙСТВО_ТЕКУЩАЯ_ЦЕНА];
	
	Если Количество <> Неопределено 
		И РесурсыПозиции.Количество() = 0 И ТекущиеЦеныПозиции.Количество() > 0 Тогда
		РассчитатьСуммуПозиции(ПозицияСметы, СтруктураПозиции);
	ИначеЕсли Количество <> Неопределено И РесурсыПозиции.Количество() > 0 Тогда
		ОбъектПозиции = РесурсыПозиции[ИНДЕКС_ПЕРВОГО_ЭЛЕМЕНТА];
		Попытка
			
			Если ОбъектПозиции[Материалы] <> Неопределено Тогда
				РассчитатьЗатратыМатериалов(ОбъектПозиции[Материалы], ПозицияСметы, СтруктураПозиции);
			КонецЕсли;
			Если ОбъектПозиции[Зарплата] <> Неопределено Тогда
				РассчитатьЗатратыРабочим(ОбъектПозиции[Зарплата], ПозицияСметы, СтруктураПозиции);
			КонецЕсли;
			Если ОбъектПозиции[Механизмы] <> Неопределено Тогда
				РассчитатьМашиныИМеханизмы(ОбъектПозиции[Механизмы], ПозицияСметы, СтруктураПозиции);
			КонецЕсли;
			
			РассчитатьСуммуВидаРабот(ПозицияСметы, СтруктураПозиции);
		Исключение
			ТекстОшибки = "Ошибка в функции ПолучитьЗатратыПозиции: " + ОписаниеОшибки();
			ВызватьИсключение ТекстОшибки;
		КонецПопытки;
	Иначе
		Возврат;
	КонецЕсли;
КонецПроцедуры
// Рассчитывает показатели в зависимости
// от наличия у позиции свойства, указывающего на старый или новый способ расчета
Процедура РассчитатьМашиныИМеханизмы(СписокТехники, КоличествоМатериала, СтруктураПозиции)
	
	Коэффициенты = СтруктураПозиции.Коэффициенты;
	
	Для Каждого Техника Из СписокТехники Цикл
		
		ТекущаяЦена = Техника[СВОЙСТВО_ТЕКУЩАЯ_ЦЕНА];
		
		Если ТекущаяЦена <> Неопределено И НЕ ЭтаПозицияУдалена(Техника) Тогда
			КоличествоТехники = Техника[СВОЙСТВО_КОЛИЧЕСТВО];
			Если ТекущаяЦена[НОВЫЙ_СПОСОБ_РАСЧЕТА] <> Неопределено Тогда
				
				РассчитатьЗарплатуПоНовомуСпособу(Техника, СтруктураПозиции);
				
			ИначеЕсли ТекущаяЦена[СТАРЫЙ_СПОСОБ_РАСЧЕТА] <> Неопределено Тогда
				РассчитатьЗарплатуПоСтаромуСпособу(Техника, СтруктураПозиции);
			Иначе
				СтруктураПозиции.ЭксплуатацияМашин = СтруктураПозиции.ЭксплуатацияМашин
				+ (ТекущаяЦена.Value * Коэффициенты.ЭксплуатацияМашин) * КоличествоТехники;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

Процедура РассчитатьЗатратыМатериалов(Материалы, Позиция, СтруктураПозиции)
	
	Коэффициенты = СтруктураПозиции.Коэффициенты;
	
	Для Каждого Материал Из Материалы Цикл
		ТекущаяЦена =  Материал[СВОЙСТВО_ТЕКУЩАЯ_ЦЕНА];
		КоличествоМатериала = Число(Материал[СВОЙСТВО_КОЛИЧЕСТВО]);
		
		Если ЭтаПозицияУдалена(Материал) И ТекущаяЦена <> Неопределено  Тогда
			СтруктураПозиции.СтоимостьМатериалов = СтруктураПозиции.СтоимостьМатериалов
			+ (ТекущаяЦена.Value * Коэффициенты.СтоимостьМатериалов)
			* КоличествоМатериала;
		КонецЕсли;
		
	КонецЦикла;
КонецПроцедуры
Процедура РассчитатьЗатратыРабочим(СписокЗарплат, Позиция, СтруктураПозиции)
	Коэффициенты = СтруктураПозиции.Коэффициенты;
	
	Для Каждого Зарплата Из СписокЗарплат Цикл
		СтруктураПозиции.ОсновнаяЗарплата = СтруктураПозиции.ОсновнаяЗарплата
		+ (Зарплата[СВОЙСТВО_ТЕКУЩАЯ_ЦЕНА].Value * Коэффициенты.ОсновнаяЗарплата)
		* Зарплата[СВОЙСТВО_КОЛИЧЕСТВО];
	КонецЦикла;
	
КонецПроцедуры

Процедура РассчитатьСуммуПозиции(Позиция, СтруктураПозиции)
	Коэффициенты = СтруктураПозиции.Коэффициенты;
	
	СтоимостьЭксплуатацииМашин = Позиция[СВОЙСТВО_ТЕКУЩАЯ_ЦЕНА][СТОИМОСТЬ_ЭКСПЛУАТАЦИИ_МАШИН];
	
	Если СтоимостьЭксплуатацииМашин <> Неопределено Тогда
		СтруктураПозиции.Цена 	= СтоимостьЭксплуатацииМашин * Коэффициенты.ЭксплуатацияМашин;
		СтруктураПозиции.Сумма 	= СтруктураПозиции.Цена * СтруктураПозиции.Количество;
		СтруктураПозиции.ЭксплуатацияМашин = СтруктураПозиции.Сумма;
	КонецЕсли;
КонецПроцедуры

Процедура РассчитатьСуммуВидаРабот(Позиция, СтруктураПозиции)
	Количество = СтруктураПозиции.Количество;
	Коэффициенты = СтруктураПозиции.Коэффициенты;
	ДопКоэффициент = Число(Коэффициенты.ДопКоэффициент);
	
	СуммаОбщая = (СтруктураПозиции.ЭксплуатацияМашин)
	+ (СтруктураПозиции.ЗарплатаМехаников)
	+ (СтруктураПозиции.ОсновнаяЗарплата)
	+ (СтруктураПозиции.СтоимостьМатериалов)
	+ (СтруктураПозиции.ОсновнаяЗарплата * ДопКоэффициент);
	
	СтруктураПозиции.Сумма 	= СуммаОбщая * Количество;
	СтруктураПозиции.ОсновнаяЗарплата 	= СтруктураПозиции.ОсновнаяЗарплата  	* Количество;
	СтруктураПозиции.ЗарплатаМехаников	= СтруктураПозиции.ЗарплатаМехаников	* Количество;
	СтруктураПозиции.ЭксплуатацияМашин	= СтруктураПозиции.ЭксплуатацияМашин	* Количество;
	СтруктураПозиции.СтоимостьМатериалов	= СтруктураПозиции.СтоимостьМатериалов
	* Количество + (СтруктураПозиции.ОсновнаяЗарплата * ДопКоэффициент);
	СтруктураПозиции.Цена 	= СуммаОбщая;
КонецПроцедуры

Процедура РассчитатьЗарплатуПоНовомуСпособу(Позиция, СтруктураПозиции)
	Коэффициенты = СтруктураПозиции.Коэффициенты;
	Цена = Позиция[НОВЫЙ_СПОСОБ_РАСЧЕТА].Price;
	Количество = Позиция[НОВЫЙ_СПОСОБ_РАСЧЕТА][СВОЙСТВО_КОЛИЧЕСТВО];
	КоличествоПозиции = Позиция[СВОЙСТВО_КОЛИЧЕСТВО];
	ТекущаяЦенаПозиции = Позиция[СВОЙСТВО_ТЕКУЩАЯ_ЦЕНА].Value;
	
	Если Цена <> Неопределено Тогда
		Если Коэффициенты.ПрименятьЭксплуатациюМашинкЗарплате Тогда
			СтруктураПозиции.ЗарплатаМехаников = СтруктураПозиции.ЗарплатаМехаников
			+ (Цена * Количество * Коэффициенты.ЗарплатаМехаников) * КоличествоПозиции;
			СтруктураПозиции.ЗарплатаМехаников = СтруктураПозиции.ЗарплатаМехаников
			* Коэффициенты.ЭксплуатацияМашин;
		Иначе
			СтруктураПозиции.ЗарплатаМехаников = СтруктураПозиции.ЗарплатаМехаников
			+ (Цена * Количество * Коэффициенты.ЗарплатаМехаников) * КоличествоПозиции;
		КонецЕсли;
	КонецЕсли;
	СтруктураПозиции.ЭксплуатацияМашин = СтруктураПозиции.ЭксплуатацияМашин
	+ (ТекущаяЦенаПозиции * Коэффициенты.ЭксплуатацияМашин) * КоличествоПозиции;
КонецПроцедуры
Процедура РассчитатьЗарплатуПоСтаромуСпособу(Позиция, СтруктураПозиции)
	Коэффициенты = СтруктураПозиции.Коэффициенты;
	
	ТекущаяЦенаЗарплаты = Позиция[СВОЙСТВО_ТЕКУЩАЯ_ЦЕНА][СТАРЫЙ_СПОСОБ_РАСЧЕТА];
	ТекущаяЦенаПозиции = Позиция[СВОЙСТВО_ТЕКУЩАЯ_ЦЕНА].Value;
	КоличествоПозиции = Позиция[СВОЙСТВО_КОЛИЧЕСТВО];
	
	СтруктураПозиции.ЗарплатаМехаников = СтруктураПозиции.ЗарплатаМехаников
	+ (ТекущаяЦенаПозиции  * Коэффициенты.ЭксплуатацияМашин)
	* КоличествоПозиции;
	Если Коэффициенты.ПрименятьЭксплуатациюМашинкЗарплате Тогда
		СтруктураПозиции.ЗарплатаМехаников =
		СтруктураПозиции.ЗарплатаМехаников * Коэффициенты.ЭксплуатацияМашин;
	КонецЕсли;
	
	СтруктураПозиции.ЭксплуатацияМашин = СтруктураПозиции.ЭксплуатацияМашин
	+ (ТекущаяЦенаПозиции * Коэффициенты.ЭксплуатацияМашин)
	- (ТекущаяЦенаЗарплаты * Коэффициенты.ЭксплуатацияМашин)
	* КоличествоПозиции;
КонецПроцедуры
#КонецОбласти

#Область РасчетыТехники
// Используется для извлечения объекта техники вложенной
// в позицию определенную как вид работ в XML-документе
// и устанавливает связь между видом работ и его техникой
// в дальнейшем для каждого вида работ
// в отдельной таблице на форме строится дерево его техники
Процедура ПолучитьТехникуВидаРабот(Позиция, СтруктураПозиции)
	
	Коэффициенты = СтруктураПозиции.Коэффициенты;
	СписокТехники = Новый Массив;
	ТехникаМассив = Новый Массив;
	
	РесурсыПозиции =  Позиция.Resources;
	ОбъектСпискаТехники = ИНДЕКС_ПЕРВОГО_ЭЛЕМЕНТА;
	ИмяСпискаТехники = "Mch";
	
	Сумма = "Value";
	
	Если РесурсыПозиции.Количество() > 0 
		И РесурсыПозиции[ОбъектСпискаТехники][ИмяСпискаТехники] <> Неопределено Тогда
		СписокТехники = РесурсыПозиции[ОбъектСпискаТехники][ИмяСпискаТехники];
	КонецЕсли;
	
	Для Каждого Техника Из СписокТехники Цикл
		СтоимостьТехники = Техника.PriceCurr;
		КоличествоТехники = Техника.Quantity;
		
		Если СтоимостьТехники = Неопределено И НЕ ЭтаПозицияУдалена(Техника) Тогда
			Продолжить;
		КонецЕсли;
		
		ТехникаВидаРабот = СоздатьОбъектВнутреннейТехники(Техника, СтруктураПозиции);
		Попытка
			Если Техника[НОВЫЙ_СПОСОБ_РАСЧЕТА] <> Неопределено Тогда
				ПолучитьЗатратыПоТехнике(Техника, ТехникаВидаРабот, СтруктураПозиции, НОВЫЙ_СПОСОБ_РАСЧЕТА);
			ИначеЕсли СтоимостьТехники[СТАРЫЙ_СПОСОБ_РАСЧЕТА] <> Неопределено Тогда
				ПолучитьЗатратыПоТехнике(Техника, ТехникаВидаРабот, СтруктураПозиции, СТАРЫЙ_СПОСОБ_РАСЧЕТА);
			Иначе
				ТехникаВидаРабот.Цена = (СтоимостьТехники[Сумма]
				* Коэффициенты.ЭксплуатацияМашин) * СтруктураПозиции.Количество;
				ТехникаВидаРабот.ЭксплуатацияМашин = ((СтоимостьТехники[Сумма] * Коэффициенты.ЭксплуатацияМашин)
				* КоличествоТехники) * СтруктураПозиции.Количество;
			КонецЕсли;
		Исключение
			ТекстОшибки = "Ошибка в функции ПолучитьТехникуВидаРабот при попытке получить затраты: " + ОписаниеОшибки();
			ВызватьИсключение ТекстОшибки;
		КонецПопытки;
		ТехникаВидаРабот.Сумма = (ТехникаВидаРабот.Цена * ТехникаВидаРабот.Количество) * СтруктураПозиции.Количество;
		ТехникаВидаРабот.СуммаВсего = ТехникаВидаРабот.Сумма;
		ТехникаМассив.Добавить(ТехникаВидаРабот);
	КонецЦикла;
	
	СтруктураПозиции.Техника = ТехникаМассив;
КонецПроцедуры
Процедура ПолучитьЗатратыПоТехнике(Позиция, Техника, СтруктураПозиции, СпособРасчета)
	Попытка
		
		Коэффициенты = СтруктураПозиции.Коэффициенты;
		РазмерОплатыМашин = Позиция[СВОЙСТВО_ТЕКУЩАЯ_ЦЕНА].Value;
		КоличествоПозиции = Позиция[СВОЙСТВО_КОЛИЧЕСТВО];
		
		Если СпособРасчета = НОВЫЙ_СПОСОБ_РАСЧЕТА Тогда
			ЦенаПоНовомуСпособу = Позиция[СпособРасчета].Price;
			КоличествоПоНовомуСпособу = Позиция[СпособРасчета][СВОЙСТВО_КОЛИЧЕСТВО];
			Если ЦенаПоНовомуСпособу <> Неопределено Тогда
				ЗарплатаМехаников = ЦенаПоНовомуСпособу * Коэффициенты.ЗарплатаМехаников;
				Если Коэффициенты.ПрименятьЭксплуатациюМашинкЗарплате Тогда
					ЗарплатаМехаников = ЗарплатаМехаников * Коэффициенты.ЭксплуатацияМашин;
				КонецЕсли;
				ЭксплуатацияМашин = РазмерОплатыМашин * Коэффициенты.ЭксплуатацияМашин;
				Техника.Цена = (ЗарплатаМехаников * КоличествоПоНовомуСпособу)
				+ ЭксплуатацияМашин * СтруктураПозиции.Количество;
				Техника.ЗарплатаМехаников = (ЗарплатаМехаников * КоличествоПоНовомуСпособу)
				* Позиция[СВОЙСТВО_КОЛИЧЕСТВО] * СтруктураПозиции.Количество;
			Иначе
				ЭксплуатацияМашин = РазмерОплатыМашин * Коэффициенты.ЭксплуатацияМашин;
				Техника.Цена = ЭксплуатацияМашин * СтруктураПозиции.Количество;
			КонецЕсли;
		ИначеЕсли СпособРасчета = СТАРЫЙ_СПОСОБ_РАСЧЕТА Тогда
			РазмерЗарплатыМехаников = Позиция[СВОЙСТВО_ТЕКУЩАЯ_ЦЕНА][СпособРасчета];
			
			ЗарплатаМехаников = РазмерЗарплатыМехаников * Коэффициенты.ЗарплатаМехаников;
			ЭксплуатацияМашин = РазмерОплатыМашин * Коэффициенты.ЭксплуатацияМашин - ЗарплатаМехаников;
			
			Техника.Цена = (ЗарплатаМехаников + ЭксплуатацияМашин) * СтруктураПозиции.Количество;
			Техника.ЗарплатаМехаников = (ЗарплатаМехаников * КоличествоПозиции) * СтруктураПозиции.Количество;
		Иначе
			Возврат;
		КонецЕсли;
		Техника.ЭксплуатацияМашин = (ЭксплуатацияМашин * КоличествоПозиции) * СтруктураПозиции.Количество;
	Исключение
		ТекстОшибки = "Ошибка в функции ПолучитьЗатратыПоТехнике: " + ОписаниеОшибки();
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
КонецПроцедуры
#КонецОбласти

#Область Коэффициенты
Функция РассчитатьИПолучитьСписокКоэффициентов(ПозицияСметы)
	СписокКоэффициентов = Новый Структура;
	СписокКоэффициентов.Вставить("ДопКоэффициент", 0);
	Процент = 100;
	Если ПозицияСметы.AuxMat <> Неопределено Тогда
		СписокКоэффициентов.ДопКоэффициент = ПозицияСметы.AuxMat / Процент;
	КонецЕсли;
	// BSLLS:Typo-off
	НомерОбъектаСпискаКоэффициентов = ИНДЕКС_ПЕРВОГО_ЭЛЕМЕНТА;
	ИмяОбъектаКоэфффициентов = "K";
	
	СписокКоэффициентов.Вставить("ЭксплуатацияМашин", 	1);
	СписокКоэффициентов.Вставить("ОсновнаяЗарплата", 	1);
	СписокКоэффициентов.Вставить("СтоимостьМатериалов",	1);
	СписокКоэффициентов.Вставить("ЗарплатаМехаников", 	1);
	СписокКоэффициентов.Вставить("ОбщийКоэффициент", 	1);
	СписокКоэффициентов.Вставить("ПрименятьЭксплутациюМашинкЗарплатеМехаников", Ложь);
	
	Коэффициенты = ПозицияСметы.Koefficients;
	
	Если Коэффициенты.Количество() > 0 Тогда
		Для Каждого Коэффициент Из Коэффициенты[НомерОбъектаСпискаКоэффициентов][ИмяОбъектаКоэфффициентов] Цикл
			РассчитатьКоэффициенты(Коэффициент, СписокКоэффициентов);
		КонецЦикла;
	КонецЕсли;
	// BSLLS:Typo-on
	Возврат СписокКоэффициентов;
КонецФункции

Процедура РассчитатьКоэффициенты(Коэффициент, СписокКоэффициентов)
	// BSLLS:Typo-off
	Если  Коэффициент[ИМЕНА_КОЭФФИЦИЕНТОВ.ОбщийКоэффициент] <> Неопределено Тогда
		СписокКоэффициентов.ОбщийКоэффициент = СписокКоэффициентов.ОбщийКоэффициент 
		* Коэффициент[ИМЕНА_КОЭФФИЦИЕНТОВ.ОбщийКоэффициент];
	КонецЕсли;
	Если Коэффициент[ИМЕНА_КОЭФФИЦИЕНТОВ.ЭксплуатацияМашин] <> Неопределено Тогда
		СписокКоэффициентов.ЭксплуатацияМашин = СписокКоэффициентов.ЭксплуатацияМашин 
		* Коэффициент[ИМЕНА_КОЭФФИЦИЕНТОВ.ЭксплуатацияМашин]
		* ОбщийКоэффициент;
	КонецЕсли;
	Если Коэффициент[ИМЕНА_КОЭФФИЦИЕНТОВ.ОпцииКоэффициентов] <> Неопределено
		И Коэффициент[ИМЕНА_КОЭФФИЦИЕНТОВ.ОпцииКоэффициентов]
		.Найти(ИМЕНА_КОЭФФИЦИЕНТОВ.ПрименятьЭксплуатациюМашинКоВсем) <> Неопределено Тогда
		СписокКоэффициентов.ПрименятьЭксплутациюМашинкЗарплатеМехаников = Истина;
	КонецЕсли;
	Если Коэффициент[ИМЕНА_КОЭФФИЦИЕНТОВ.ОсновнаяЗарплата] <> Неопределено Тогда
		СписокКоэффициентов.ОсновнаяЗарплата = СписокКоэффициентов.ОсновнаяЗарплата 
		* Коэффициент[ИМЕНА_КОЭФФИЦИЕНТОВ.ОсновнаяЗарплата]
		* СписокКоэффициентов.ОбщийКоэффициент;
	КонецЕсли;
	Если Коэффициент[ИМЕНА_КОЭФФИЦИЕНТОВ.СтоимостьМатериалов] <> Неопределено Тогда
		СписокКоэффициентов.СтоимостьМатериалов = СписокКоэффициентов.СтоимостьМатериалов 
		* Коэффициент[ИМЕНА_КОЭФФИЦИЕНТОВ.СтоимостьМатериалов]
		* СписокКоэффициентов.ОбщийКоэффициент;
	КонецЕсли;
	Если Коэффициент[ИМЕНА_КОЭФФИЦИЕНТОВ.ЗарплатаМехаников] <> Неопределено Тогда
		СписокКоэффициентов.ЗарплатаМехаников = СписокКоэффициентов.ЗарплатаМехаников 
		* Коэффициент[ИМЕНА_КОЭФФИЦИЕНТОВ.СвойствоЗарплатаМехаников]
		* СписокКоэффициентов.ОбщийКоэффициент;
	КонецЕсли;
	// BSLLS:Typo-on
КонецПроцедуры
#КонецОбласти

#Область СлужебныеОперации
// Формирует общую структуру для строки сметы
Функция СоздатьОбъектПозицииСметы(ПозицияСметы, ТипЗатрат, Коэффициенты)
	ПустаяСсылка = Справочники.СопоставлениеПозицицйСметы.ПустаяСсылка();
	СтруктураПозиции = Новый Структура;
	
	НаименованиеПозиции = СтрЗаменить(ПозицияСметы.Caption, Символы.ПС, "");
	НаименованиеПозиции = СтрЗаменить(НаименованиеПозиции, Символы.ВК, "");
	СтруктураПозиции.Вставить("Идентификатор", 	 ПозицияСметы.SysID);
	СтруктураПозиции.Вставить("Наименование",	 НаименованиеПозиции);
	СтруктураПозиции.Вставить("ТипЗатрат",	  	 ТипЗатрат);
	СтруктураПозиции.Вставить("ЕдиницаИзмерения", ПозицияСметы.Units);
	СтруктураПозиции.Вставить("НомерПозиции", 	 ПозицияСметы.Number);
	СтруктураПозиции.Вставить("ОбоснованиеКод",  ПозицияСметы.Code);
	СтруктураПозиции.Вставить("ДавальческийМатериал", Ложь);
	СтруктураПозиции.Вставить("Цена", 				0);
	СтруктураПозиции.Вставить("Сумма", 				0);
	СтруктураПозиции.Вставить("Сопоставление", 		ПустаяСсылка);
	СтруктураПозиции.Вставить("ОсновнаяЗарплата", 	0);
	СтруктураПозиции.Вставить("ПодчиненнаяРабота", 	Ложь);
	СтруктураПозиции.Вставить("ЭтоПодраздел", 	Ложь);
	СтруктураПозиции.Вставить("ЭксплуатацияМашин", 	0);
	СтруктураПозиции.Вставить("ЗарплатаМехаников", 	0);
	СтруктураПозиции.Вставить("СтоимостьМатериалов", 0);
	СтруктураПозиции.Вставить("НакладныеРасходы", 	0);
	СтруктураПозиции.Вставить("ПлановыеРасходы", 	0);
	СтруктураПозиции.Вставить("Техника", Новый Массив);
	СтруктураПозиции.Вставить("ВнутренниеПозиции", Новый Массив);
	СтруктураПозиции.Вставить("СопоставлениеВидаРабот", ПустаяСсылка);
	СтруктураПозиции.Вставить("Коэффициенты", Коэффициенты);
	СтруктураПозиции.Вставить("Хеш", 0);
	Если ПозицияСметы.Quantity1.Количество() > 0 Тогда
		СтруктураПозиции.Вставить("Количество", 	 ПозицияСметы.Quantity1[ИНДЕКС_ПЕРВОГО_ЭЛЕМЕНТА].Result);
	Иначе
		СтруктураПозиции.Вставить("Количество", 	 0);
	КонецЕсли;
	
	Возврат СтруктураПозиции;
КонецФункции
Функция СоздатьОбъектВнутреннейТехники(Техника, СтруктураПозиции)
	
	ПустаяСсылка = Справочники.СпоставлениеПозицийСметы.ПустаяСсылка();
	НомерПозиции = СтрРазделить(Техника.Code, "-")[1];
	ТехникаВидаРабот = Новый Структура;
	ТехникаВидаРабот.Вставить("Наименование", 		Техника.Caption);
	ТехникаВидаРабот.Вставить("ОбоснованиеКод", 	Техника.Code);
	ТехникаВидаРабот.Вставить("НомерПозиции", 		НомерПозиции);
	ТехникаВидаРабот.Вставить("Сопоставление", 		ПустаяСсылка);
	ТехникаВидаРабот.Вставить("ЕдиницаИзмерения", 	Техника.Units);
	ТехникаВидаРабот.Вставить("Количество", 		Техника.Quantity);
	ТехникаВидаРабот.Вставить("Цена", 				0);
	ТехникаВидаРабот.Вставить("Сумма", 				0);
	ТехникаВидаРабот.Вставить("ЗарплатаМехаников",  0);
	ТехникаВидаРабот.Вставить("ЭксплуатацияМашин",  0);
	ТехникаВидаРабот.Вставить("ТипЗатрат", 			Перечисления.ТипыЗатрат.Техника);
	ТехникаВидаРабот.Вставить("СуммаВсего", 		0);
	ТехникаВидаРабот.Вставить("СсылкаВидаРабот", 	ПустаяСсылка);
	ТехникаВидаРабот.Вставить("Хеш", 0);
	ТехникаВидаРабот.Вставить("ХешВидаРабот", СтруктураПозиции.Хеш);
	
	Возврат ТехникаВидаРабот;
	
КонецФункции
Функция ВычислитьХешПозиции(Строка, Кэш)
	ИзКэша = Кэш.Получить(Строка);
	Если ИзКэша <> Неопределено Тогда
		Возврат ИзКэша;
	КонецЕсли;
	
	// Решение использовать эту функцию вместо CRC обсоновано тем, что
	// CRC дает слишком много коллизий, и подходит для сравнения,
	// но не для генерации уникальных значений
	// в то время как FNVa1 так же дает 32-разрядное целое число на выходе,
	// при этом достаточно низкое число коллизий
	// и сохраняет высокую скорость вычисления
	// Однако нужно учесть что 1С не позволяет использовать
	// побитовые операции для чисел больше 32-разрядных,
	// и потому был немного модифицирован под реалии 1С
	
	БазаСмещения = 2166136261;
	ОсноваАлгоритма = 16777619;
	МаксимальноеЦелое = 4294967296;
	// BSLLS:MagicNumber-off
	Байты = Новый Массив(СтрДлина(Строка));
	Для Индекс = 0 По Байты.ВГраница() Цикл
		Код = КодСимвола(Строка, Индекс + 1);
		Байты[Индекс] =
		(ПобитовыйСдвигВправо(Код, 6) + 192) 
		* 256 + (ПобитовоеИ(Код, 63) + 50);
		// Числа здесь математически вычислены авторами функции
	КонецЦикла;
	// BSLLS:MagicNumber-on
	Хеш = БазаСмещения;
	
	Для Каждого Байт Из Байты Цикл
		Хеш = ПобитовоеИсключительноеИли(Хеш, Байт) * ОсноваАлгоритма;
		Хеш = Хеш % МаксимальноеЦелое; // Иммитируем переполнение
	КонецЦикла;
	
	Кэш.Вставить(Строка, Хеш);
	Возврат Хеш;
	
КонецФункции

// Используется для установки связи хеша и соответствия в специальном справочнике
// Поскольку в XML может быть добавлено множество
// наименований означающих один и тот же элемент справочника
// а искать по каждой уникальной строке соответствующее наименование достаточно трудоемко
// Существует справочник хранящий пару Хеш-Элемент номенклатуры
// поэтому используется вычисление хеша по строке,
// и последующий поиск элемента по хешу в этом справочнике.
Функция ПолучитьСписокСоответствующихЭлементовСправочника()
	СоответствияПоХешу = Новый Соответствие;
	Попытка
		Запрос = Новый Запрос;
		Запрос.Текст = "
		|ВЫБРАТЬ С.Сопоставление КАК ЭлементСправочника, Хеш КАК Хеш
		|ИЗ Справочник.СопоставлениеПозицийСметы КАК С
		|ГДЕ С.Хеш В (&МассивХешей)";
		Запрос.УстановитьПараметр("МассивХешей", МассивХешейНаименований);
		
		Выборка = Запрос.Выполнить().Выбрать();
		
		Пока Выборка.Следующий() Цикл
			СоответствияПоХешу.Вставить(Выборка.Хеш, Выборка.ЭлементСправочника);
		КонецЦикла;
	Исключение
		ТекстОшибки = СтрШаблон("Ошибка в функции %1: %2",
		"ПолучитьСписокСоответствующихЭлементовСправочника", ОписаниеОшибки());
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
	Возврат СоответствияПоХешу;
КонецФункции
Процедура ЗаполнитьСоответствияПоХешуНаименования(ОбъектСметы)
	Попытка
		СписокРазделов = ОбъектСметы.Смета;
		СписокСоответствий = ПолучитьСписокСоответствующихЭлементовСправочника();
		
		Для Каждого Раздел Из СписокРазделов Цикл
			
			Для Каждого СтрокаРаздела Из Раздел Цикл
				
				СтрокаРаздела.Сопоставление = СписокСоответствий.Получить(СтрокаРаздела.Хеш);
				Если СтрокаРаздела.ТипЗатрат = Перечисления.ТипыЗатрат.Работы Тогда
					СтрокаРаздела.СопоставлениеВидаРабот = СтрокаРаздела.Сопоставление;
					ЗаполнитьСоответствияТехникиВидаРабот(СписокСоответствий, СтрокаРаздела);
				КонецЕсли;
				
			КонецЦикла;
		КонецЦикла;
		
	Исключение
		ТекстОшибки = СтрШаблон("Ошибка в функции %1: %2",
		"ЗаполнитьСоответствияПоХешуНаименования", ОписаниеОшибки());
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
КонецПроцедуры

Процедура ЗаполнитьСоответствияТехникиВидаРабот(СписокСоответствий, СтрокаРаздела)
	Если СтрокаРаздела.Техника.Количество > 0 Тогда
		Для Каждого СтрокаТехники Из СтрокаРаздела.Техника Цикл
			СтрокаТехники.СопоставлениеВидаРабот = СтрокаРаздела.Сопоставление;
			СтрокаТехники.Сопоставление = СписокСоответствий.Получить(СтрокаТехники.Хеш);
		КонецЦикла;
	КонецЕсли;
КонецПроцедуры
#КонецОбласти

#Область ИнициализацияПеременных

МассивХешейНаименований = Новый Массив;
КэшНаименований = Новый Соответствие;

ИМЕНА_КОЭФФИЦИЕНТОВ = Новый Структура;
ИМЕНА_КОЭФФИЦИЕНТОВ.Вставить("ПрименятьЭксплуатациюМашинКоВсем", "EmAll");
ИМЕНА_КОЭФФИЦИЕНТОВ.Вставить("ОпцииКоэффициентов", "Options");
ИМЕНА_КОЭФФИЦИЕНТОВ.Вставить("ОбщийКоэффициент", "Value_PZ");
ИМЕНА_КОЭФФИЦИЕНТОВ.Вставить("ЭксплуатацияМашин", "Value_EM");
ИМЕНА_КОЭФФИЦИЕНТОВ.Вставить("ОсновнаяЗарплата", "Value_OZ");
ИМЕНА_КОЭФФИЦИЕНТОВ.Вставить("СтоимостьМатериалов", "Value_MT");
ИМЕНА_КОЭФФИЦИЕНТОВ.Вставить("ЗарплатаМехаников", "Value_ZM");

ИНДЕКС_ПЕРВОГО_ЭЛЕМЕНТА = 0;
НОВЫЙ_СПОСОБ_РАСЧЕТА = "Tzm2022";
СТАРЫЙ_СПОСОБ_РАСЧЕТА = "ZM";
ТИП_ВИДОВ_РАБОТ = "Виды работ 2001г";
ТИП_ВИДА_РАБОТ = "Vr2001";
СТОИМОСТЬ_МАТЕРИАЛОВ = "MT";
СТОИМОСТЬ_ЭКСПЛУАТАЦИИ_МАШИН = "EM";
СВОЙСТВО_КОЛИЧЕСТВО = "Quantity";
СВОЙСТВО_ТЕКУЩАЯ_ЦЕНА = "PriceCurr";
#КонецОбласти
